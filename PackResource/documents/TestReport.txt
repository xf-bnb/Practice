
测试目标：
准确性     检查打好的资源包中的数据应与原文件一致，并且保持原有目录的相对位置。
稳定性     检查资源包加载/释放操作准确性，以及在多线程环境中访问资源应保持同步。
运行效率   比较从资源包中读取资源速度和从磁盘中读取资源文件速度，评估性能。


测试前的准备：
1：创建4个目录：
.../TestPack/res1
.../TestPack/res2
.../TestPack/res3
.../TestPack/res4
2：分别放入若干不同类型的资源文件当作测试数据，4个目录总数据量大小超过1G。
3：创建目录 .../TestPack/compare，拷贝 res1、res2 目录中的文件到该目录中。
4：创建目录 .../TestPack/total，拷贝 res1、res2、res3、res4 4个目录中的文件到该目录中。
5：执行 ResourcePackager[.exe] 命令行工具，分别对4个目录依次打包，并指定资源包文件名为原目录名：
示例：.../ResourcePackager .../TestPack/res1 res1，打包成功将生成对应的资源包文件。

至此测试数据准备完成，测试目录 .../TestPack 结构应如下：
.../TestPack/res1
.../TestPack/res2
.../TestPack/res3
.../TestPack/res4
.../TestPack/compare
.../TestPack/total
.../TestPack/res1.respackage
.../TestPack/res2.respackage
.../TestPack/res3.respackage
.../TestPack/res4.respackage



测试步骤：
已在测试模块(ResourceTest)中编写了多个测试函数，分别对上述性能进行验证。
编译 ResourceTest 模块生成测试可执行程序，输入不同测试指令执行测试方法。

Windows：
进入 .../projects/vs_2017 目录打开 Visual Studio 工程文件，在 IDE 中右键重新生成 ResourceTest 项目。
打开命令提示符窗口(CMD)执行测试程序：
.../output/ResourceTest/Release/ResourceTest.exe [number]|[function name]

Linux/OS X:
进入 .../projects/gcc 目录执行 [debug/release].sh 脚本，编译生成测试可执行程序。
打开终端执行测试程序：
.../output/ResourceTest/Release/ResourceTest [number]|[function name]



测试指令：
执行：.../ResourceTest 0
或者：.../ResourceTest test_recover
该指令将执行测试函数 test_recover，执行过程为：
加载两个之前已经打好的资源包：res1.respackage、res2.respackage
获取已经存在的资源名列表，并根据获取的资源名列表逐个获取资源数据。
创建目录 recover，根据资源名创建文件并将对应获取到的资源数据写入其中。
待所有资源写入完毕，测试程序执行结束，屏幕日志打印资源加载记录和文件写入记录。
使用对比工具比较 compare 文件夹和 recover 文件夹，检查目录结构和文件内容是否一致。

执行：.../ResourceTest 1
或者：.../ResourceTest test_release
该指令将执行测试函数 test_release，执行过程为：
加载一个资源包，获取存在的资源名列表，根据资源名列表读取资源数据。
屏幕日志将打印资源加载记录、获取到的资源名称和读取到的资源长度。
对比原有目录中的文件信息，检查是否一致，按任意键继续加载下一个资源，重复上述过程。
待所有资源包加载完毕，按任意键继续，开始逐个释放资源包，同时重复上述检查操作。
待所有资源包释放完毕，测试程序执行结束。

执行：.../ResourceTest 2
或者：.../ResourceTest test_compare
该指令将执行测试函数 test_compare，执行过程为：
加载所有资源包，获取存在的资源名列表。
根据资源名列表从资源包中获取资源数据，记录获取的数据总字节数和花费的时间。
根据资源名列表从 total 目录中读取文件，记录读取到的总字节数和花费的时间。
读取磁盘文件使用的是标准库 std::ifstream，待所有文件读取完毕，测试程序执行结束。
屏幕日志将打印资源加载记录和两种方式读取的总字节数，花费的时间，读取速度。
对比两种方式读取的数据量是否一致，以及和 total 目录中总文件大小是否一致。
对比读取速度以评估性能。注意：为避免系统缓存干扰，建议重启计算机执行该项测试。

执行：.../ResourceTest 3
或者：.../ResourceTest test_thread
该指令将执行测试函数 test_thread，执行过程为：
加载所有资源包，获取存在的资源名列表。
创建一个线程根据资源名列表逐个获取资源数据(按名称列表顺序获取资源)。
创建一个线程随机根据资源名列表获取资源数据(按名称列表随机获取资源)。
创建两个线程重复读取列表中第一个资源数据(读取次数等于列表长度，形成竞争关系)。
创建两个线程重复读取列表中最后一个资源数据(读取次数等于列表长度，形成竞争关系)
创建一个线程间隔一定时间(目前是256ms)逐个释放资源。
总共7个线程同时执行，待所有线程全部退出，测试程序执行结束：
屏幕日志打印资源加载和释放记录，打印获取资源记录，日志信息附有当前时间戳和所在线程ID。
分析日志记录，检查获取资源结果和释放时机是否正确匹配，检查程序执行过程是否出现异常。



测试结果：
所有测试指令均在 Windows 和 OS X 系统中执行完成，测试结果如下：

执行测试：.../ResourceTest 0
屏幕日志打印正常，两个资源包均加载成功，所有资源均写入到 recover 文件夹成功。
使用对比工具 Beyond Compare 对 recover 和 compare 两个文件夹进行对比，两个文件夹结构和内容完全一致。

执行测试：.../ResourceTest 1
屏幕日志打印正常，所有资源包均加载/释放成功，资源信息日志正常。
4个资源包总共601个文件，打印逐步加载和释放过程中存在的资源信息。
通过对比，资源加载和释放过程中，日志打印出来的资源信息和资源原有目录中的文件信息一致。

执行测试：.../ResourceTest 2
屏幕日志打印正常，所有资源包均加载成功，成功打印出两种方式下的读取速度。
第一次执行结果是在重启计算机之后进行的测试。
可以看出，两种方式下读取的数据总量一致，并且与 total 文件夹中的文件总大小一致。
在加载过超过1G的数据量的情况下，资源访问接口 API 的性能要优于直接从磁盘读取操作(OS X 差异较 Windows 更明显)，而在第二次执行时候两种方式的性能都有明显提升。

执行测试：.../ResourceTest 3
屏幕日志打印正常，所有资源包均加载/释放成功，资源访问未见异常。
所有资源包加载成功，多个线程同步访问资源都能成功。
第一个资源包释放之后，部分线程访问资源失败，而该资源正是在第一个资源包当中。
所有资源包释放结束之后，所有线程访问资源都将失败。
通过对日志的分析得出，多线程访问资源始终保持同步，测试执行过程中未见任何异常。



结论：
1：准确性：资源打包命令行工具能正确对文件夹进行打包，资源加载和访问接口能正确访问资源并能按目录结构还原数据。
2：稳定性：在多线程环境下多个资源访问操作和释放操作能保持同步有序进行。
3：性能：通过与标准库文件读取API(std::ifstream)对比，使用资源访问接口获取数据性能要优于文件读取API(性能大概是文件读取的1.2-1.8倍，但仅在一台 Windows 和一台 Mac 上测试)。并且在二次访问(有系统缓存)情况下，性能也能随之提升。

